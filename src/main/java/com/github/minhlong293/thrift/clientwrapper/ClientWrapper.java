package com.github.minhlong293.thrift.clientwrapper;

import com.github.minhlong293.thrift.clientpool.BaseClient;
import com.github.minhlong293.thrift.common.ThriftExceptionHelper;
import org.apache.thrift.TException;
import org.apache.thrift.transport.TTransport;
import org.apache.thrift.transport.TTransportException;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.BiFunction;
import java.util.function.Function;

/**
 * This class wraps the client object by using Java Proxy.
 *
 * @param <T> Iface class, which is generated by Thrift
 * @param <K> Client class, must implements Iface interface, generated by Thrift.
 *
 * @author minhlong293
 */
public class ClientWrapper<T, K extends T> extends BaseClient {
    private final String host;
    private final int port;
    private K clientObject;
    private Class iFaceClazz;
    private T clientInvocationHandler;
    private TTransport transport;
    private final BiFunction<String, Integer, TTransport> transportSupplier;
    private final Function<TTransport, K> clientSupplier;
    private AtomicBoolean isConnected = new AtomicBoolean(false);

    /**
     *
     * @param host server host
     * @param port server port
     * @param transportSupplier TTransport supplier function
     * @param clientSupplier Client supplier function
     * @param iFaceClazz the Iface class generated by Thrift (Iface.class)
     */
    public ClientWrapper(String host,
                         int port,
                         BiFunction<String, Integer, TTransport> transportSupplier,
                         Function<TTransport, K> clientSupplier,
                         Class iFaceClazz) {
        this.host = host;
        this.port = port;
        this.transportSupplier = transportSupplier;
        this.clientSupplier = clientSupplier;
        this.iFaceClazz = iFaceClazz;
        try {
            connect();
        } catch (TException e) {
            this.isConnected.set(false);
        }
    }

    /**
     * Get the Iface object, you can use it to call methods defined in Iface.
     * @return client object wrapped by Java Proxy, it is thread-safe
     */
    public T getClient() {
        return this.clientInvocationHandler;
    }

    @Override
    public boolean isConnected() {
        return this.isConnected.get();
    }

    @Override
    public void disconnect() {
        this.transport.close();
        this.isConnected.set(false);
    }

    @Override
    public void connect() throws TException {
        synchronized (this) {
            if (!this.isConnected()) {
                this.transport = this.transportSupplier.apply(this.host, this.port);
                this.transport.open();
                this.clientObject = this.clientSupplier.apply(transport);
                this.clientInvocationHandler = (T) Proxy.newProxyInstance(ClientWrapper.class.getClassLoader(),
                        new Class[]{this.iFaceClazz},
                        new ClientInvocationHandler<>(this.clientObject));
                this.isConnected.set(true);
            }
        }
    }

    /**
     * Wrap the real client. All client methods are wrapped by invoke(), so we can handle all exceptions and make methods synchronized.
     * @param <T> Client class
     */
    private class ClientInvocationHandler<T> implements InvocationHandler {
        private T target;

        ClientInvocationHandler(T target) {
            this.target = target;
        }

        private void checkTException(TException e) {
            if (ThriftExceptionHelper.isDisconnectedException(e)) {
                ClientWrapper.this.isConnected.set(false);
            }
        }

        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            if (!ClientWrapper.this.isConnected()) throw new TTransportException();
            synchronized (target) {
                try {
                    return method.invoke(target, args);
                } catch (InvocationTargetException e) {
                    if (e.getTargetException() instanceof TException) {
                        checkTException((TException) e.getTargetException());
                    }
                    throw e.getTargetException();
                }
            }
        }
    }
}
